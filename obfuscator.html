<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AST-based JS Obfuscator (Fixed)</title>
<style>
  body{font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;margin:0;background:#071029;color:#d8eefc}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  textarea{width:100%;height:280px;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:#021022;color:#d8eefc;font-family:monospace}
  .row{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
  .col{flex:1;min-width:160px}
  button{padding:10px 12px;border-radius:8px;border:none;background:#06b6d4;color:#042029;font-weight:700;cursor:pointer}
  pre{white-space:pre-wrap;background:#021022;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.04);font-family:monospace}
  label{display:inline-flex;gap:8px;align-items:center}
  .small{font-size:13px;color:#9fb6d0}
  footer{margin-top:18px;color:#9fb6d0;font-size:13px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>AST ベース JS 難読化（修正版）</h1>
    <p class="small">Acorn + acorn-walk + Astring を使い、識別子の安全なリネーム、文字列テーブル化（XOR→Base64）、数値変換を行うデモ。複雑なコードはバックアップを取ってから。</p>

    <label>元コード（貼り付け）</label>
    <textarea id="src" placeholder="ここに JavaScript を貼り付け"></textarea>

    <div class="row">
      <div class="col"><label><input type="checkbox" id="rename" checked /> 識別子をリネーム</label></div>
      <div class="col"><label><input type="checkbox" id="strings" checked /> 文字列をテーブル化・暗号化</label></div>
      <div class="col"><label><input type="checkbox" id="numbers" /> 数値を可逆変換（高レベル向け）</label></div>
      <div class="col"><label>プレフィックス<input id="prefix" value="AruCube" style="width:140px;margin-left:8px" /></label></div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col"><label class="small">XOR キー（HEX）: <input id="xorKey" value="0x5a" style="width:100px;margin-left:8px" /></label></div>
      <div class="col"><label class="small">難読化レベル: <select id="level"><option value="1">低</option><option value="2" selected>中</option><option value="3">高</option></select></label></div>
      <div style="flex:1"></div>
      <div><button id="run">Obfuscate</button></div>
    </div>

    <h3 style="margin-top:16px">出力</h3>
    <pre id="out" style="min-height:260px"></pre>

    <div style="display:flex;gap:8px;margin-top:10px">
      <button id="copy">出力をコピー</button>
      <button id="download">ダウンロード (.js)</button>
      <button id="showPreview">簡易復号プレビュー</button>
    </div>

    <footer>
      <p>注意: eval や Function で動的に生成されるコード、DOM 側のグローバル参照など特殊ケースは解析できない場合があります。必ずテストしてください。</p>
    </footer>
  </div>

  <!-- CDN: acorn, acorn-walk, astring -->
  <script src="https://unpkg.com/acorn@8.8.2/dist/acorn.min.js"></script>
  <script src="https://unpkg.com/acorn-walk@8.2.0/dist/walk.min.js"></script>
  <script src="https://unpkg.com/astring@1.8.1/dist/astring.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/acorn/dist/acorn.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/acorn-walk/dist/walk.min.js"></script>

  <script>
  // ---- ヘルパー ----
  function uid(len=6){ const chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; let s=''; for(let i=0;i<len;i++) s+=chars[Math.floor(Math.random()*chars.length)]; return s; }
  function isReservedGlobal(name){
    const r = ['window','document','console','JSON','Math','Array','Object','String','Number','Boolean','Date','setTimeout','clearTimeout','setInterval','clearInterval','RegExp','Map','Set','WeakMap','WeakSet','Promise','require','module','exports'];
    return r.includes(name);
  }

  // ---- 汎用ウォーカー ----
  // walkAndReplace: 深さ優先で AST を回す。コールバックが false を返すとそのノードの子は走査しない。
  function walkAndReplace(node, cb, parent=null, key=null, idx=null){
    if(!node || typeof node.type !== 'string') return;
    const doChildren = cb(node, parent, key, idx);
    if(doChildren === false) return;
    for(const k in node){
      if(!Object.prototype.hasOwnProperty.call(node,k)) continue;
      const v = node[k];
      if(Array.isArray(v)){
        for(let i=0;i<v.length;i++){
          const child = v[i];
          if(child && typeof child.type === 'string'){
            walkAndReplace(child, cb, node, k, i);
          }
        }
      } else if(v && typeof v.type === 'string'){
        walkAndReplace(v, cb, node, k, null);
      }
    }
  }

  // ---- 主処理: AST を使った難読化 ----
  function obfuscateWithAST(code, opts){
    // parse
    const ast = acorn.parse(code, {ecmaVersion:2020, sourceType:'module'});

    // collect string literals and numbers
    const stringTable = [];
    const stringIndex = new Map();
    const numericNodes = [];

    walkAndReplace(ast, (node)=>{
      if(node.type === 'Literal' && typeof node.value === 'string'){
        const s = node.value;
        if(!stringIndex.has(s)){
          stringIndex.set(s, stringTable.length);
          stringTable.push(s);
        }
      }
      if(node.type === 'Literal' && typeof node.value === 'number'){
        numericNodes.push(node);
      }
      return true;
    });

    // If strings option off, skip building table
    let headerCode = '';
    const tableVar = opts.prefix + '_strs';
    const decName = opts.prefix + '_dec';
    if(opts.strings && stringTable.length > 0){
      const key = opts.xorKey & 0xFF;
      const encTable = stringTable.map(s=>{
        const bytes = [];
        for(let i=0;i<s.length;i++) bytes.push(s.charCodeAt(i)^key);
        const bin = String.fromCharCode(...bytes);
        return btoa(bin);
      });
      headerCode = `const ${tableVar}=[${encTable.map(s=>JSON.stringify(s)).join(',')}];\nfunction ${decName}(i){\n  const b64=${tableVar}[i];\n  const s=atob(b64);\n  let out='';\n  for(let k=0;k<s.length;k++) out+=String.fromCharCode(s.charCodeAt(k)^${key});\n  return out;\n}\n\n`;
      // replace string literals with decoder calls
      walkAndReplace(ast, (node,parent,key,idx)=>{
        if(node.type === 'Literal' && typeof node.value === 'string'){
          const i = stringIndex.get(node.value);
          if(typeof i === 'number'){
            const callNode = { type:'CallExpression', callee:{type:'Identifier', name:decName}, arguments:[{type:'Literal', value:i}] };
            if(Array.isArray(parent[key]) && idx!==null) parent[key][idx] = callNode;
            else parent[key] = callNode;
            return false;
          }
        }
        return true;
      });
    }

    // Identifier renaming (simple but safer)
    if(opts.rename){
      // collect declaration names (FunctionDeclaration, VariableDeclarator, ClassDeclaration)
      const defs = new Map();
      walkAndReplace(ast, (node)=>{
        if(node.type === 'FunctionDeclaration' && node.id && node.id.name && !isReservedGlobal(node.id.name)){
          defs.set(node.id.name, uid(6));
        } else if(node.type === 'VariableDeclarator' && node.id && node.id.type==='Identifier'){
          const n = node.id.name;
          if(!isReservedGlobal(n)) defs.set(n, uid(6));
        } else if(node.type === 'ClassDeclaration' && node.id && node.id.name){
          const n = node.id.name;
          if(!isReservedGlobal(n)) defs.set(n, uid(6));
        }
        return true;
      });
      // rename occurrences (naive replacement of Identifier nodes)
      if(defs.size>0){
        walkAndReplace(ast, (node)=>{
          if(node.type === 'Identifier'){
            const n = node.name;
            if(defs.has(n) && !isReservedGlobal(n)){
              node.name = opts.prefix + '_' + defs.get(n);
            }
          }
          return true;
        });
      }
    }

    // Numeric obfuscation (high level only)
    if(opts.obfuscateNumbers){
      walkAndReplace(ast, (node,parent,key,idx)=>{
        if(node.type === 'Literal' && typeof node.value === 'number'){
          const n = node.value;
          const off = Math.floor(Math.random()*1000)+1;
          const wrapped = {
            type: 'BinaryExpression', operator:'^',
            left: { type:'BinaryExpression', operator:'^', left:{type:'Literal', value:n}, right:{type:'Literal', value:off} },
            right: {type:'Literal', value:off}
          };
          if(Array.isArray(parent[key]) && idx!==null) parent[key][idx] = wrapped;
          else parent[key] = wrapped;
          return false;
        }
        return true;
      });
    }

    // generate code
    const generated = astring.generate(ast, {indent:'  '});
    let final = headerCode + generated;

    if(opts.level >= 2){
      final = `(function(${opts.prefix}_g){try{\n${final}\n}catch(e){console.error('${opts.prefix}_err',e);throw e;}})('${uid(12)}');`;
    }

    return final;
  }

  // ---- UI binding ----
  document.getElementById('run').addEventListener('click', ()=>{
    const src = document.getElementById('src').value || '';
    if(!src.trim()){ alert('ソースを貼り付けてください'); return; }
    const opts = {
      rename: document.getElementById('rename').checked,
      strings: document.getElementById('strings').checked,
      obfuscateNumbers: document.getElementById('numbers').checked,
      prefix: (document.getElementById('prefix').value || 'AruCube').replace(/[^A-Za-z0-9_]/g,'') || 'AruCube',
      xorKey: (()=>{ let k = document.getElementById('xorKey').value||'0x5a'; if(/^0x[0-9a-fA-F]+$/.test(k)) return parseInt(k,16); return 0x5a; })(),
      level: parseInt(document.getElementById('level').value||'2',10)
    };
    try{
      const out = obfuscateWithAST(src, opts);
      document.getElementById('out').textContent = out;
    }catch(err){
      console.error(err);
      alert('難読化中にエラーが発生しました。コンソールを確認してください。');
    }
  });

  document.getElementById('copy').addEventListener('click', ()=>{
    const t = document.getElementById('out').textContent || '';
    if(!t) return alert('出力がありません');
    navigator.clipboard.writeText(t).then(()=>alert('コピーしました')).catch(()=>alert('コピーに失敗しました'));
  });

  document.getElementById('download').addEventListener('click', ()=>{
    const t = document.getElementById('out').textContent || '';
    if(!t) return alert('出力がありません');
    const blob = new Blob([t], {type:'text/javascript'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='obfuscated.js'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  document.getElementById('showPreview').addEventListener('click', ()=>{
    const out = document.getElementById('out').textContent || '';
    if(!out) return alert('出力がありません');
    // extract table by regex
    const re = new RegExp('const\\s+(\\w+_strs)\\s*=\\s*\\[([\\s\\S]*?)\\]\\s*;');
    const m = out.match(re);
    if(!m) return alert('文字列テーブルが見つかりません');
    const arrText = '[' + m[2] + ']';
    try{
      const arr = eval(arrText); // base64 strings only
      const keyMatch = out.match(/atob\\(b64\\);[\\s\\S]*?charCodeAt\\(k\\) \\^ (\\d+)/) || out.match(/charCodeAt\\(k\\) \\^ (\\d+)/);
      const key = keyMatch ? parseInt(keyMatch[1],10) : null;
      if(key === null) return alert('XOR キーが検出できません');
      const decoded = arr.map(b64=>{
        const s = atob(b64);
        let o=''; for(let i=0;i<s.length;i++) o+=String.fromCharCode(s.charCodeAt(i)^key);
        return o;
      });
      alert('デコードプレビュー（先頭20件まで）:\n' + decoded.slice(0,20).join('\n---\n'));
    }catch(e){
      console.error(e);
      alert('プレビューに失敗しました（コンソールを確認）');
    }
  });

  </script>
</body>
</html>
